// This file is computer-generated by onnx2c 
// (TODO: add creating command line here)
// (TODO: print creation date here )

// ONNX model:
// produced by pytorch, version 2.6.0
// ONNX IR version: 13
// Model documentation: 
/*

*/

#include <float.h>
#include <math.h>
#include <stdbool.h>
#include <stdint.h>
#include <string.h>

#include "topk_test.h"

#define MAX(X,Y) ( X > Y ? X : Y)
#define MIN(X,Y) ( X < Y ? X : Y)
#define CLIP(X,L) ( MAX(MIN(X,L), -L) )

#if __STDC_VERSION__ < 199901L
#define FUNC_PREFIX
#else
#define FUNC_PREFIX static inline
#endif

static const int64_t tensor__Constant_output_0[1] = 
{3};

/*
 * Operand:           Constant
 * Name in ONNX file: /Constant
 */
FUNC_PREFIX void node__Constant( const int64_t output[1] )
{
	/* Constant */
	/* The output is generated as a global tensor */
	(void)output;
}

/*
 * Operand:           TopK
 * Name in ONNX file: /TopK
 */
FUNC_PREFIX void node__TopK( const float X[1][5][10], const int64_t K[1], float Values[1][3][10], int64_t Indices[1][3][10] )
{
	/* TopK with largest=1, sorted=1, other options not currently supported */
	for (int i0 = 0; i0 < 1; i0++) {
		for (int i2 = 0; i2 < 10; i2++) {
			for (int k = 0; k < 3; k++) {
				Values[i0][k][i2] = -1e10;
				Indices[i0][k][i2] = -1;
			}
			for (int k = 0; k < 5; k++) {
				for (int d = 0; d < 3; d++) {
					if (X[i0][k][i2] > Values[i0][d][i2]) {
						for (int s = 2; s > d; s--) {
							Values[i0][s][i2] = Values[i0][s - 1][i2];
							Indices[i0][s][i2] = Indices[i0][s - 1][i2];
						}
						Values[i0][d][i2] = X[i0][k][i2];
						Indices[i0][d][i2] = k;
						break;
					}
				}
			}
		}
	}
}


void entry(const float tensor_input[1][5][10], float tensor_topk_values[1][3][10], int64_t tensor_topk_indices[1][3][10]){
	node__Constant( tensor__Constant_output_0);
	node__TopK( tensor_input, tensor__Constant_output_0, tensor_topk_values, tensor_topk_indices);
}
